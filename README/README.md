# Assigntment 1 - Chatbot

##### Zhengxi Tian - zt586

Xinyu Xiao - xx869



## Description

This is a Restaurant Suggestion Restaurant Chatbot based on AWS. Developed by Zhengxi Tian.

Log in URL: 

```
https://userlogin.auth.us-east-1.amazoncognito.com//login?response_type=token&client_id=4cjq38p0p3rf8tgltccbg22vh7&redirect_uri=https://s3.amazonaws.com/test1-cc/chatbox.html
```



## Features

- Sign up for new user
- Login and logout
- Real-time chat and response for the requirements



## AWS Services

- Authentication with **Amazon Cognito User Pools**.
- Serverless computing with **AWS Lambda**.
- API access control provided by **Amazon API Gateway**.
- Static site hosting on **Amazon S3**.
- Create chatbot using the **Amazon Lex** service.



## S3 Bucket

1. Create bucket

2. Add a bucket policy to make bucket content publicly available

   If cannot add bucket policy, check `Manage public access control lists (ACLs)` and turn them to False.

   ![bucket-permission](/Users/macbook/Desktop/chatbot_zt/README/bucket-permission.png)

3. Upload `chatbot.html` and javascript SDK to S3, then make public resources in S3. The main codes include in S3 folder are `chatbot.html` and `apiGateway-js-sdk`.



## Swagger

Specification: OpenAPI Specification, an API description format for REST APIs.

Syntax: `YAML`

Version: `Swagger 2.0`

#### Parameter Description

**1. chabot:** `/chatbot`

- $POST: send message
- $GET: get message



## API Gateway

1. Upload swagger API to the API Gateway: [AI Customer Service API](https://console.aws.amazon.com/apigateway/home?region=us-east-1#/apis/1jdb55uq51/resources)
2. Create lambda function for each REST API, connect API Gateway with Lambda.
   - Test API and lambda functions.
   - Watch testing logs via CloudWatch.
3. Add IAM authorization on `Method Request`.
4. Enable CORS on API methods.
5. Deploy API in `Actions` and generate SDK for API

- Install, initiate and call a JavaScript SDK generated by API Gateway for a REST API.

- Create a API key first:

  `flx55nycvg`

  ![API-key](/Users/macbook/Desktop/chatbot_zt/README/API-key.png)

-  Include references to the following scripts:

  ```html
  <script type="text/javascript" src="lib/axios/dist/axios.standalone.js"></script>
  <script type="text/javascript" src="lib/CryptoJS/rollups/hmac-sha256.js"></script>
  <script type="text/javascript" src="lib/CryptoJS/rollups/sha256.js"></script>
  <script type="text/javascript" src="lib/CryptoJS/components/hmac.js"></script>
  <script type="text/javascript" src="lib/CryptoJS/components/enc-base64.js"></script>
  <script type="text/javascript" src="lib/url-template/url-template.js"></script>
  <script type="text/javascript" src="lib/apiGatewayCore/sigV4Client.js"></script>
  <script type="text/javascript" src="lib/apiGatewayCore/apiGatewayClient.js"></script>
  <script type="text/javascript" src="lib/apiGatewayCore/simpleHttpClient.js"></script>
  <script type="text/javascript" src="lib/apiGatewayCore/utils.js"></script>
  <script type="text/javascript" src="apigClient.js"></script>
  ```

- To use an API key with the SDK generated by API Gateway, pass the API key as a parameter to the `Factory` object by using code similar to the following. If you use an API key, it is specified as part of the `x-api-key` header and all requests to the API will be signed. This means you must set the appropriate CORS Accept headers for each request.

  ```javascript
  // Initialize the SDK for API Gateway
  // Use API key, have to set the appropriate CORS Accept headers for each request
          var apigClient = apigClientFactory.newClient({
              apiKey: 'flx55nycvg';  // this is the API_key for 'chatbot'
          });
  ```

- Call the API methods in API Gateway by using code similar to the following. Each call returns a promise with a success and failure callbacks.

- `apigClient.js` file, main codes are shown below:

  - Set app client:

  ```javascript
  var apigClientFactory = {};
  apigClientFactory.newClient = function (config) {
      var apigClient = { };
      if(config === undefined) {
          config = {
              accessKey: 'chatbot',
              secretKey: 'zt586@nyu.edu',
              sessionToken: '',
              region: 'us-east-1',
              apiKey: undefined,
              defaultContentType: 'application/json',
              defaultAcceptType: 'application/json'
          };
      }
  ```

  - Call `$GET` API:

  ```javascript
  apigClient.chatbotGet = function (params, body, additionalParams) {
          if(additionalParams === undefined) { additionalParams = {}; }
          
          apiGateway.core.utils.assertParametersDefined(params, [], ['body']);
          
          var chatbotGetRequest = {
              verb: 'get'.toUpperCase(),
              path: pathComponent + uritemplate('/chatbot').expand(apiGateway.core.utils.parseParametersToObject(params, [])),
              headers: apiGateway.core.utils.parseParametersToObject(params, []),
              queryParams: apiGateway.core.utils.parseParametersToObject(params, []),
              body: body
          };
          
          
          return apiGatewayClient.makeRequest(chatbotGetRequest, authType, additionalParams, config.apiKey);
      };
  ```

  - Call `$ POST` API:

  ```javascript
  apigClient.chatbotPost = function (params, body, additionalParams) {
          if(additionalParams === undefined) { additionalParams = {}; }
          
          apiGateway.core.utils.assertParametersDefined(params, ['body'], ['body']);
          
          var chatbotPostRequest = {
              verb: 'post'.toUpperCase(),
              path: pathComponent + uritemplate('/chatbot').expand(apiGateway.core.utils.parseParametersToObject(params, [])),
              headers: apiGateway.core.utils.parseParametersToObject(params, []),
              queryParams: apiGateway.core.utils.parseParametersToObject(params, []),
              body: body
          };
          
          
          return apiGatewayClient.makeRequest(chatbotPostRequest, authType, additionalParams, config.apiKey);
      };
  ```



## Lambda

1. Give credentials to the role in lambda function via IAM.

2. Author a Python lambda function from scratchã€‚

   ![author-lambda](/Users/macbook/Desktop/chatbot_zt/README/author-lambda.png)

   - Select `Author from scratch`. Create a name for the lambda function.
   - Change runtime to `Python 3.6`.
   - Create a new Role from template or create custom role in the IAM console. As for the policy option, we can leave it present and add policies later in IAM.

3. Amazon CloudWatch Logs

- Watching testing logs for Lambda and API Gateway.

4. Integrate lambda (LF0) with Lex, using `POST_TEXT` method in  ` boto3`.

   ```python
   import json
   from datetime import *
   import boto3
   
   def lambda_handler(event, context):
       """
       This function is aim to implement the function of sending messages
       """
       client = boto3.client('lex-runtime')
       
       # print("event shows here", event, sep = '-----')
       body = event["body"]
       
       # json-fy the event first to extract
       body = json.loads(body)
       msg_cont = body["messages"][0]
      
       msg_strc = msg_cont["unstructured"]
       msg_text = msg_strc["text"]
       
       response = client.post_text(
           botName ='chatbot',
           botAlias ='zxtian',
           userId ='kelly',
           inputText = msg_text
       )
       
       return_msg = response["message"]
   
       response = {'id': msg_strc['id'], 
                   'text': return_msg, 
                   'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")} # convert datetime to string
       
       return {
           'statusCode': 200,
           'headers': { 
               "Access-Control-Allow-Origin": "*" 
           },
           'body': json.dumps(response)
       }
   ```

5. Lambda (LF1) used to interact with Lex and call external Yelp API.

   ```python
   """
   This sample demonstrates an implementation of the Lex Code Hook Interface
   in order to serve a sample bot which manages reservations for hotel rooms and car rentals.
   Bot, Intent, and Slot models which are compatible with this sample can be found in the Lex Console
   as part of the 'BookTrip' template.
   
   For instructions on how to set up and test this bot, as well as additional samples,
   visit the Lex Getting Started documentation http://docs.aws.amazon.com/lex/latest/dg/getting-started.html.
   """
   from __future__ import print_function
   
   import json
   import datetime
   import time
   import os
   import dateutil.parser
   import logging
   from botocore.vendored import requests
   import sys
   import urllib
   
   logger = logging.getLogger()
   logger.setLevel(logging.DEBUG)
   
   
   try:
       # For Python 3.0 and later
       from urllib.error import HTTPError
       from urllib.parse import quote
       from urllib.parse import urlencode
   except ImportError:
       # Fall back to Python 2's urllib2 and urllib
       from urllib2 import HTTPError
       from urllib import quote
       from urllib import urlencode
   
   """
   # Yelp Fusion no longer uses OAuth as of December 7, 2017.
   # You no longer need to provide Client ID to fetch Data
   # It now uses private keys to authenticate requests (API Key)
   # You can find it on https://www.yelp.com/developers/v3/manage_app
   """
   # Call the external API
   API_KEY= "SrHaKm69SIfHIZXjD_M9GJMrNUfoqpHhT508oRRFnM18UbSEycvEcOc4EoYJzyUGy2fCqrVXwO_cRLeAei_qellDKnbY5MtcOXbETW_FgyXdLUUSnoDo8ILiysiKXHYx" 
   
   API_HOST = 'https://api.yelp.com'
   SEARCH_PATH = '/v3/businesses/search'
   BUSINESS_PATH = '/v3/businesses/'  # Business ID will come after slash.
   
   
   # Defaults for our simple example.
   DEFAULT_TERM = 'dinner'
   DEFAULT_LOCATION = 'San Francisco, CA'
   SEARCH_LIMIT = 3
   
   def request(host, path, api_key, url_params=None):
       """Given your API_KEY, send a GET request to the API.
       Args:
           host (str): The domain host of the API.
           path (str): The path of the API after the domain.
           API_KEY (str): Your API Key.
           url_params (dict): An optional set of query parameters in the request.
       Returns:
           dict: The JSON response from the request.
       Raises:
           HTTPError: An error occurs from the HTTP request.
       """
       url_params = url_params or {}
       url = '{0}{1}'.format(host, quote(path.encode('utf8')))
       headers = {
           'Authorization': 'Bearer %s' % api_key,
       }
   
       print(u'Querying {0} ...'.format(url))
   
       response = requests.request('GET', url, headers=headers, params=url_params)
   
       return response.json()
   
   
   def search(api_key, term, location):
       """Query the Search API by a search term and location.
       Args:
           term (str): The search term passed to the API.
           location (str): The search location passed to the API.
       Returns:
           dict: The JSON response from the request.
       """
   
       url_params = {
           'term': term.replace(' ', '+'),
           'location': location.replace(' ', '+'),
           'limit': SEARCH_LIMIT
       }
       return request(API_HOST, SEARCH_PATH, api_key, url_params=url_params)
   
   # --- Helpers that build all of the responses ---
   
   
   def elicit_slot(session_attributes, intent_name, slots, slot_to_elicit, message):
       return {
           'sessionAttributes': session_attributes,
           'dialogAction': {
               'type': 'ElicitSlot',
               'intentName': intent_name,
               'slots': slots,
               'slotToElicit': slot_to_elicit,
               'message': message
           }
       }
   
   
   def confirm_intent(session_attributes, intent_name, slots, message):
       return {
           'sessionAttributes': session_attributes,
           'dialogAction': {
               'type': 'ConfirmIntent',
               'intentName': intent_name,
               'slots': slots,
               'message': message
           }
       }
   
   
   def close(session_attributes, fulfillment_state, message):
       response = {
           'sessionAttributes': session_attributes,
           'dialogAction': {
               'type': 'Close',
               'fulfillmentState': fulfillment_state,
               'message': message
           }
       }
   
       return response
   
   
   def delegate(session_attributes, slots):
       return {
           'sessionAttributes': session_attributes,
           'dialogAction': {
               'type': 'Delegate',
               'slots': slots
           }
       }
   
   
   # --- Helper Functions ---
   
   
   def safe_int(n):
       """
       Safely convert n value to int.
       """
       if n:
           return int(n)
       return n
   
   
   def try_ex(func):
       """
       Call passed in function in try block. If KeyError is encountered return None.
       This function is intended to be used to safely access dictionary.
   
       Note that this function would have negative impact on performance.
       """
       try:
           return func()
       except KeyError:
           return None
   
   
   
   def isvalid_city(city):
       valid_cities = ['new york', 'los angeles', 'chicago', 'houston', 'philadelphia', 'phoenix', 'san antonio',
                       'san diego', 'dallas', 'san jose', 'austin', 'jacksonville', 'san francisco', 'indianapolis',
                       'columbus', 'fort worth', 'charlotte', 'detroit', 'el paso', 'seattle', 'denver', 'washington dc',
                       'memphis', 'boston', 'nashville', 'baltimore', 'portland', 'manhattan', 'queens', 'brooklyn', 'flushing']
       return city.lower() in valid_cities
   
   
   def isvalid_cuisine(cuisine):
   	valid_cuisines = ['chinese', 'japanese', 'korean', 'spanish', 'american', 'bbq', 'steakhouse', 'bar']
   	return cuisine.lower() in valid_cuisines
   
   
   def isvalid_date(date):
       try:
           dateutil.parser.parse(date)
           return True
       except ValueError:
           return False
   
   
   
   def build_validation_result(isvalid, violated_slot, message_content):
       return {
           'isValid': isvalid,
           'violatedSlot': violated_slot,
           'message': {'contentType': 'PlainText', 'content': message_content}
       }
   
   
   
   def validate_requirement(slots):
       location = try_ex(lambda: slots['Location'])
       cuisine = try_ex(lambda: slots['cuisine'])
       dining_date = try_ex(lambda: slots['dining_date'])
   
       if location and not isvalid_city(location):
           return build_validation_result(
               False,
               'location',
               'We currently do not support {} as a valid destination.  Can please you try a different city?'.format(location)
           )
   
       if cuisine and not isvalid_cuisine(cuisine):
           return build_validation_result(
               False,
               'cuisine',
               'We currently do not support {} as a valid cuisine.  Can you please try a different cuisine?'.format(cuisine)
           ) 
   
       if dining_date:
           if not isvalid_date(dining_date):
               return build_validation_result(False, 'dining_date', 'I did not understand your date.  When would you like to have dinner?')
           if datetime.datetime.strptime(dining_date, '%Y-%m-%d').date() <= datetime.date.today():
               return build_validation_result(False, 'dining_date', 'Reservations must be scheduled at least one day in advance.  Can you try a different date?')
   
       return {'isValid': True}
   
   
   """ --- Functions that control the bot's behavior --- """
   
   
   def suggest_dining(intent_request):
       """
       Performs dialog management and fulfillment for suggest a dinner.
   
       Beyond fulfillment, the implementation for this intent demonstrates the following:
       1) Use of elicitSlot in slot validation and re-prompting
       2) Use of sessionAttributes to pass information that can be used to guide conversation
       """
   
       location = try_ex(lambda: intent_request['currentIntent']['slots']['location'])
       cuisine = try_ex(lambda: intent_request['currentIntent']['slots']['cuisine'])
       number_people = try_ex(lambda: intent_request['currentIntent']['slots']['number_people'])
       dining_date = try_ex(lambda: intent_request['currentIntent']['slots']['dining_date'])
       dating_time = try_ex(lambda: intent_request['currentIntent']['slots']['dating_time'])
       
       session_attributes = intent_request['sessionAttributes'] if intent_request['sessionAttributes'] is not None else {}
   
       # Load confirmation history and track the current reservation.
       suggestion = json.dumps({
           'location': location,
           'cuisine': cuisine,
           'number_people': number_people,
           'dining_date': dining_date,
           'dating_time': dating_time
       })
   
       session_attributes['suggestion'] = suggestion
   
       if intent_request['invocationSource'] == 'DialogCodeHook':
           # Validate any slots which have been specified.  If any are invalid, re-elicit for their value
           validation_result = validate_requirement(intent_request['currentIntent']['slots'])
           if not validation_result['isValid']:
               slots = intent_request['currentIntent']['slots']
               slots[validation_result['violatedSlot']] = None
   
               return elicit_slot(
                   session_attributes,
                   intent_request['currentIntent']['name'],
                   slots,
                   validation_result['violatedSlot'],
                   validation_result['message']
               )
   
           session_attributes['suggestion'] = suggestion
           return delegate(session_attributes, intent_request['currentIntent']['slots'])
   
       logger.debug('suggested dinner under={}'.format(suggestion))
   
       try_ex(lambda: session_attributes.pop('suggestion'))
       session_attributes['lastConfirmedReservation'] = suggestion
   
       # Invoke Yelp API
       yelp_response = search(API_KEY, "restaurant", location)
       name = yelp_response['businesses'][0]['name']
       address = yelp_response['businesses'][0]['location']['address1']
   
       return close(
           session_attributes,
           'Fulfilled',
           {
               'contentType': 'PlainText',
               'content': 'Here are my {} restaurant suggestions for {} people, for {} at {}: 1. {} located at {} '.format(cuisine, number_people, dining_date, dating_time, name, address)
           }
       )
   
   def trivial_response(intent_request):
   	pass
   
   # --- Intents ---
   
   def dispatch(intent_request):
       """
       Called when the user specifies an intent for this bot.
       """
   
       logger.debug('dispatch userId={}, intentName={}'.format(intent_request['userId'], intent_request['currentIntent']['name']))
   
       intent_name = intent_request['currentIntent']['name']
   
       # Dispatch to your bot's intent handlers
       if intent_name == 'DiningSuggestionsIntent':
           return suggest_dining(intent_request)
       elif intent_name == 'GreetingIntent' or intent_name == 'ThankYouIntent':
           return trivial_response(intent_request)
   
       raise Exception('Intent with name ' + intent_name + ' not supported')
   
   
   # --- Main handler ---
   
   
   def lambda_handler(event, context):
       """
       Route the incoming request based on intent.
       The JSON body of the request is provided in the event slot.
       """
       # By default, treat the user request as coming from the America/New_York time zone.
       os.environ['TZ'] = 'America/New_York'
       time.tzset()
       logger.debug('event.bot.name={}'.format(event['bot']['name']))
   
       return dispatch(event)
   ```



## Cognito

1. Manage user pools

   - Create a user pool.

   - Review default settings to create a user pool.

     ```bash
     Pool Id: us-east-1_KMfefSLmw
     Pool ARN: arn:aws:cognito-idp:us-east-1:066177567294:userpool/us-east-1_KMfefSLmw
     ```

2. Add an app client in user pool

- App client settings: 

  - Sign-in and sign-out URL settings: set sign-in URL here to complete the sign-in process of chatbot.
  - OAuth 2.0: 
    - [x] Authorization code grant
    - [x] implicit grant: which will give the JWT tokens
    - [x] Allowed OAuth scope: email...

- Create an Amazon cognito domain

  `http://userlogin.auth.us-east-1.amazoncognito.com`

  ![appintegretion](/Users/macbook/Desktop/chatbot_zt/README/appintegretion.png)

- Type the domain in a new web page

  - Add in the following: 

    `/login?response_type=token&client_id=4cjq38p0p3rf8tgltccbg22vh7&redirect_uri=https://s3.amazonaws.com/test1-cc/chatbox.html`

    - `client_id` is the App client ID shows in the left side.
    - `redirect_uri` is the callable URL in sign-in part.

  - If you want the code response: `/login?response_type=code`

3. Log-in web page

```html
https://userlogin.auth.us-east-1.amazoncognito.com//login?response_type=token&client_id=4cjq38p0p3rf8tgltccbg22vh7&redirect_uri=https://s3.amazonaws.com/test1-cc/chatbox.html
```

![sign-in](/Users/macbook/Desktop/chatbot_zt/README/sign-in.png)

4. Identity Pool:

   - Giving identity credentials in `chatbot.html`:

     ```javascript
     function parseJwt (token) {
                 var base64Url = token.split('.')[1];
                 var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                 return window.atob(base64);
             };
     		// set the focus to the input box
     		document.getElementById("wisdom").focus();
     
     		// Initialize the Amazon Cognito credentials provider
     		var token = window.location.hash.split('&')[0].split('=')[1]
     
     		var accessKeyId;
     		var secretAccessKey;
     		var sessionToken;
     
     		AWS.config.region = 'us-east-1';
     
     		
     		// Configure the credentials provider to use your identity pool
     		// AWS.config.credentials = new AWS.CognitoIdentityCredentials({
     		myCredentials = new AWS.CognitoIdentityCredentials({
     			IdentityPoolId: 'us-east-1:46e47174-cb7a-4a50-a055-4a86158460b8',
     			Logins: {
     					'cognito-idp.us-east-1.amazonaws.com/us-east-1_KMfefSLmw': token
     				}
     		});
     ```

   - Adding `"Access-Control-Allow-Origin"` in headler in Lambda:

     ```javascript
     return {
             'statusCode': 200,
             'headers': { 
                 "Access-Control-Allow-Origin": "*" 
             },
             'body': json.dumps(response)
         }
     ```



## Lex

1. Intent contains:

- GreetingIntent
- ThankYouIntent
- DiningSuggestionsIntent: Integrating `DiningSuggestionIntent` with LF1.

![dinningIntent](/Users/macbook/Desktop/chatbot_zt/README/dinningIntent.png)

2. To start conversation:

- Utterance to trigger **GreetingIntent**

   - Hi
   - Hello
   - I need some restaurant suggestions

- Utterance to trigger **DiningSuggestionsIntent**

   - I need help.
   - I don't know where to eat.
   - I need some restaurant suggestions.

- Utterance to trigger **ThankYouIntent**

   - Thanks
   - Thank you
   - Thanks for your help

2. Call Yelp API:

   ```python
   # Call the external API
   API_KEY= "SrHaKm69SIfHIZXjD_M9GJMrNUfoqpHhT508oRRFnM18UbSEycvEcOc4EoYJzyUGy2fCqrVXwO_cRLeAei_qellDKnbY5MtcOXbETW_FgyXdLUUSnoDo8ILiysiKXHYx" 
   
   API_HOST = 'https://api.yelp.com'
   SEARCH_PATH = '/v3/businesses/search'
   BUSINESS_PATH = '/v3/businesses/'  # Business ID will come after slash.
   
   
   # Invoke Yelp API
   yelp_response = search(API_KEY, "restaurant", location)
   name = yelp_response['businesses'][0]['name']
   address = yelp_response['businesses'][0]['location']['address1']
   ```

   
